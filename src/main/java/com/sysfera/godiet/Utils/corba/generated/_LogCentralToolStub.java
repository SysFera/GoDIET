
package com.sysfera.godiet.Utils.corba.generated;

/**
* _LogCentralToolStub.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from ./goDiet/Utils/CORBA/idl/LogTool.idl
* mercredi 26 janvier 2011 17 h 07 CET
*/


/**
 * methods offered by the core to allow tools to attach
 * and configure filters
 */
public class _LogCentralToolStub extends org.omg.CORBA.portable.ObjectImpl implements LogCentralTool
{


  /**
     * Do nothing but usefull to be sure that the object is reachable
     */
  public void test ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("test", true);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                test (        );
            } finally {
                _releaseReply ($in);
            }
  } // test


  /**
     * Connect a Tool with its toolName, which must be unique among all
     * tools. The return value indicates the success of the connection.
     * If ALREADYEXISTS is returned, the tool could not be attached, as
     * the specified toolName already exists. In this case the tool must
     * reconnect with another name before specifying any filters. If the 
     * tool sends an empty toolName, the LogCentral will provide a unique
     * toolName and pass it back to the tool.
     */
  public short connectTool (org.omg.CORBA.StringHolder toolName, ToolMsgReceiver msgReceiver)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("connectTool", true);
                $out.write_string (toolName.value);
                ToolMsgReceiverHelper.write ($out, msgReceiver);
                $in = _invoke ($out);
                short $result = $in.read_short ();
                toolName.value = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return connectTool (toolName, msgReceiver        );
            } finally {
                _releaseReply ($in);
            }
  } // connectTool


  /**
     * Disconnects a connected tool from the monitor. No further 
     * filterconfigurations should be sent after this call. The 
     * toolMsgReceiver will not be used by the monitor any more 
     * after this call. Returns NOTCONNECTED if the calling tool
     * was not connected.
     */
  public short disconnectTool (String toolName)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("disconnectTool", true);
                $out.write_string (toolName);
                $in = _invoke ($out);
                short $result = $in.read_short ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return disconnectTool (toolName        );
            } finally {
                _releaseReply ($in);
            }
  } // disconnectTool


  /**
     * Returns a list of possible tags. This is just a convenience
     * functions and returns the values that are specified in a
     * configuration file. If the file is not up to date, the 
     * application may generate more tags than defined in this
     * list.
     */
  public String[] getDefinedTags ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getDefinedTags", true);
                $in = _invoke ($out);
                String $result[] = tag_list_tHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getDefinedTags (        );
            } finally {
                _releaseReply ($in);
            }
  } // getDefinedTags


  /**
     * Returns a list of actually connected Components. This is just
     * a convenience function, as the whole state of the system will
     * be sent to the tool right after connection (in the form of
     * messages)
     */
  public String[] getDefinedComponents ()
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getDefinedComponents", true);
                $in = _invoke ($out);
                String $result[] = component_list_tHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getDefinedComponents (        );
            } finally {
                _releaseReply ($in);
            }
  } // getDefinedComponents


  /**
     * Create a filter for this tool on the monitor. Messages matching
     * this filter will be forwarded to the tool. The filter will be
     * identified by its name, which is a part of filter_t. A tool
     * can have as much filters as it wants. Returns ALREADYEXISTS if
     * another filter with this name is already registered.
     */
  public short addFilter (String toolName, filter_t filter)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("addFilter", true);
                $out.write_string (toolName);
                filter_tHelper.write ($out, filter);
                $in = _invoke ($out);
                short $result = $in.read_short ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return addFilter (toolName, filter        );
            } finally {
                _releaseReply ($in);
            }
  } // addFilter


  /**
     * Removes a existing filter from the tools filterList. The filter
     * will be identified by its name in the filter_t. If the specified
     * filter does not exist, NOTEXISTS is returned.
     */
  public short removeFilter (String toolName, String filterName)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("removeFilter", true);
                $out.write_string (toolName);
                $out.write_string (filterName);
                $in = _invoke ($out);
                short $result = $in.read_short ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return removeFilter (toolName, filterName        );
            } finally {
                _releaseReply ($in);
            }
  } // removeFilter


  /**
     * Removes all defined filters.
     */
  public short flushAllFilters (String toolName)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("flushAllFilters", true);
                $out.write_string (toolName);
                $in = _invoke ($out);
                short $result = $in.read_short ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return flushAllFilters (toolName        );
            } finally {
                _releaseReply ($in);
            }
  } // flushAllFilters

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:LogCentralTool:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  private void readObject (java.io.ObjectInputStream s) throws java.io.IOException
  {
     String str = s.readUTF ();
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.Object obj = org.omg.CORBA.ORB.init (args, props).string_to_object (str);
     org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
     _set_delegate (delegate);
  }

  private void writeObject (java.io.ObjectOutputStream s) throws java.io.IOException
  {
     String[] args = null;
     java.util.Properties props = null;
     String str = org.omg.CORBA.ORB.init (args, props).object_to_string (this);
     s.writeUTF (str);
  }
} // class _LogCentralToolStub
